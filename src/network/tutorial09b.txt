<img src="http://proghammer.files.wordpress.com/2010/09/chessgame_72.jpg" alt="chess icon 72" title="chessgame_72" width="72" height="72" class="alignleft size-full wp-image-102" /> 
After we have covered the client part of networking, let's have a look at the server. It's Python, it's Google App Engine, it's XML-RPC and it is very straight forward.
<!--more-->
<blockquote>
This is an addition to the ninth part in a series of articles about programming a chess game in Java using Swing. As all articles build upon each other, I encourage you to also have a look at the previous articles in this series (<a href="http://proghammer.wordpress.com/2010/08/10/chess01-dragging-game-pieces/">Chess01: Dragging game pieces</a>, <a href="http://proghammer.wordpress.com/2010/08/16/chess02-introducing-game-state/">Chess02: Introducing game state</a>, <a href="http://proghammer.wordpress.com/2010/09/10/chess03-separating-game-logic-from-user-interface-logic/">Chess03: Separating view and logic</a>, <a href="http://proghammer.wordpress.com/2010/09/16/chess04-implementing-an-alternative-user-interface/">Chess04: Implementing an alternative user interface</a>, <a href="http://proghammer.wordpress.com/2010/09/22/chess05-enforcing-game-rules/">Chess05: Enforcing game rules</a>, <a href="http://proghammer.wordpress.com/2010/10/12/chess06-highlighting-valid-target-locations/">Chess06: Highlighting valid target locations</a>, <a href="http://proghammer.wordpress.com/2010/11/25/chess07-new-game-flow-handling/">Chess07: New game flow handling and AI preparation</a>, <a href="https://proghammer.wordpress.com/2010/11/30/chess08-implementing-an-ai-artificial-intelligence-player/">Chess08: Implementing an AI (artificial intelligence) player</a>, <a href="http://proghammer.wordpress.com/2011/07/19/chess09-playing-over-network/">Chess09: Playing over network</a>).
</blockquote>

After I have received a comment asking for details on the server side implementation of the networking part, I have decided to share the code in a short tutorial.

In article nine, I defined the protocol that we are using to communicate between the chess clients and the server. I decided to go with an <a href="http://www.xmlrpc.com/spec">XML-RPC</a> based protocol with the following methods:

[sourcecode language="java"]
/**
 * Creates a new channel on the server.
 * @param password - password for sending messages
 *                   to this channel
 * @return a unique channel identifier the new channel
 */
public String createChannel(password);

/**
 * Varify if the channel_id exists and if the password
 * is valid for this channel.
 * @param channelId - channel identifier for validation
 * @param password - channel password for validation
 * @return true if specified channel exists and password
 * is valid, else false
 */
public boolean isValid(channelId, password);

/**
 * Receive last message from the specified channel. Note,
 * that reading is public (no password required).
 * @param channelId - channel identifier
 * @return message text
 */
public String getLastMessage(channelId);

/**
 * Send the specified message to the given channel.
 * @param channelId - channel identifier
 * @param password - channel password
 * @param message - message text
 * @return message identifier
 */
public String sendMessage(channelId, password, messageText);

[/sourcecode]

The protocol is very basic. It allows the creation of new password-protected channels, it is able to store messages in these channels and provide these messages back on request. You can go back to article nine (<a href="http://proghammer.wordpress.com/2011/07/19/chess09-playing-over-network/">Chess09: Playing over network</a>) to read about the details.

Now let's have a look at the server part. The server is implemented in Python and is currently being hosted on Google App Engine. The implementation starts by listing the required imports and defining the persistent classes that we are going to use.

[sourcecode language="python"]
import datetime
from google.appengine.ext import db
from SimpleXMLRPCServer import CGIXMLRPCRequestHandler
from exceptions import Exception

# persistent channel
#   contains password and creation_date
#
class Channel(db.Model):
	password = db.StringProperty()
	creation_date = db.DateTimeProperty()

# persistent message
#   contains message and creation date
#
class Message(db.Model):
	message = db.StringProperty()
	creation_date = db.DateTimeProperty()
[/sourcecode]

As you can see, we are going to store channel objects and a message objects.

Then we define another class, which implements the methods that we would like to expose as XML-RPC services.

[sourcecode language="python"]
# xml-rpc handler class
#
class Handler():

	# create a new channel with the specified password
	# and return the unique id for this channel
	#
	def createChannel(self, pstr_password):

		# create new channel
		#
		channel = Channel()
		channel.creation_date = datetime.datetime.now()
		channel.password = pstr_password 
		channel.put()
		
		# return channel id as string
		#
		return str(channel.key().id())

	# send message into channel (including password for authentication)
	#
	def sendMessage(self, pstr_channel_id, pstr_password, pstr_message_text):
		# get channel
		channel = getChannel(pstr_channel_id)
		
		# verfy password
		if channel.password != pstr_password:
			raise ValueError('Invalid password for channel: ' + pstr_channel_id)

		# create and store message
		message = Message(parent=channel)
		message.message = pstr_message_text
		message.creation_date=datetime.datetime.now()
		message.put()

		# return unique message id
		return str(message.key().id())

	# check if password is correct for specified channel id
	#
	def isValid(self, pstr_channel_id, pstr_password):
		channel = getChannel(pstr_channel_id)

		if channel.password != pstr_password:
			return "false"
		else:
			return "true"

	# get last message that was sent into the specified channel
	# (note: reading does not need authentication)
	#
	def getLastMessage(self, pstr_channel_id):
		channel = getChannel(pstr_channel_id)
	
		query_messages = db.GqlQuery("SELECT * FROM Message where ANCESTOR IS :1 order by creation_date desc", channel.key())
		result = query_messages.fetch(1)
		if result == None or len(result) == 0:
			return " "
		else:
			return result[0].message

[/sourcecode]

And finally we need to expose the methods above as XML-RPC services, by registering the handler to an XML-RPC request handler.

[sourcecode language="python"]
handler = Handler()

# register handler class for xml-rpc
#
xml_handler = CGIXMLRPCRequestHandler()
xml_handler.register_introspection_functions()
xml_handler.register_instance(handler)
xml_handler.handle_request()
[/sourcecode]

That's basically all there is. For the full source code see below.

Resources:

The source code (eclipse project): coming soon
The chess icons come from: <a href="http://ixian.com/chess/jin-piece-sets/">http://ixian.com/chess/jin-piece-sets/</a>
<a href="http://www.xmlrpc.com/spec">XML-RPC Specification</a>
<a href="http://code.google.com/appengine/">Google App Engine</a>